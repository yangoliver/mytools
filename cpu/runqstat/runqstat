#!/usr/bin/python


"""
A tool that could show tasks information on Linux per-CPU runq
"""

import sys
from optparse import OptionParser
import re
import subprocess
import time
from time import sleep

__version__ = '0.1'

def gen_numa():
    """Generate NUMA info"""
    cpunodes = {}
    numacores = {}
    maxnode = 0
    out = subprocess.Popen('numactl --hardware | grep cpus', shell=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    errtxt = out.stderr.readline()
    if errtxt:
        print errtxt + '\r\n'
        print "Is numactl installed?\r"
        exit(1)
    for line in out.stdout.readlines():
        arr = line.split()
        if arr[0] == "node" and arr[2] == "cpus:" and len(arr) > 3:
            node = arr[1]
            numacores[node] = arr[3:]
            maxnode += 1
            for core in arr[3:]:
                cpunodes[core] = node
    return numacores, cpunodes, maxnode

def print_numa_header(numacores, cpunodes, maxnode):
    """print runqstat header"""

    for node in numacores.keys():
        fmtstr = "Node" + node
        for cpu in numacores[node]:
            fmtstr += "\tCPU" + cpu
        print fmtstr


def header_parse(out):
    """sched_debug header parse"""

    while True:
        line = out.readline()
        if re.search("Sched Debug Version:", line):
            print line
        if re.search("sched_clock_stable", line):
            print line
            break

def sysctl_sched_parse(out):
    """sysctl_sched parse"""

    print_start = 0
    while True:
        line = out.readline()
        if re.search("sysctl_sched", line):
            print_start = 1
        if print_start:
            print line
        if print_start and re.search("^\n$", line):
            print_start = 0
            break

def runq_parse(out):
    """runq parse"""
    cpu_name = {}
    runqs = {}
    cpu_found = {}

    cpu = 0
    cpu_found[cpu] = 0
    runqs[cpu] = -1
    for line in out.readlines():
        if re.search("cpu#", line):
            cpu_found[cpu] = 1
            cpu_name[cpu] = "cpu" + str(cpu)
        if re.search("\.nr_running", line):
            if cpu_found[cpu]:
                cpu_data = line.split(':')
                runqs[cpu] = cpu_data[1].strip('\n')
                cpu += 1
                cpu_found[cpu] = 0

    fmtstr = ''
    for cpu in cpu_found.keys():
        if cpu_found[cpu]:
            fmtstr += '\t' + runqs[cpu]

    print fmtstr+'\n'

def runq_stat(seconds):
    """Main I/O loop"""

    numacores, cpunodes, maxnode = gen_numa()

    print_once = 1
    out = open('/proc/sched_debug', 'r')
    while True:
        if print_once == 1:
            header_parse(out)
            sysctl_sched_parse(out)
            print "CPU runq task numbers for every %d second(s) \n" % seconds
            print_once = 0

        print time.ctime() + '\n'
        print_numa_header(numacores, cpunodes, maxnode)
        runq_parse(out)

        for _ in range(0, seconds * 10):
            sleep(.1)

        out.seek(0,0)

    out.close()

def main(args):
    """Parse arguments, call main loop"""

    parser = OptionParser(description=__doc__)

    parser.add_option("-v", "--version", action="store_true",
                      help="get version")
    parser.add_option("-t", "--time", default='5',
                      help="update interval in seconds")

    options = parser.parse_args(args)[0]

    if options.version:
        print __version__
        return 0

    try:
        runq_stat(int(options.time))
    except (KeyboardInterrupt, SystemExit):
        pass

if __name__ == "__main__":
    sys.exit(main(sys.argv))
